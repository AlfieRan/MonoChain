# 2.2.5 Cycle 5 - Signatures and Key Generation

* Choose the DSA algorithm for fast verification
* Generate DSA key pairs
* Created wrappers for the pre-existing functions
* Built a verification function to check the new key pair

## Design

### Objectives

The next module that needs implementing and introducing to the code base is the cryptography side, this is the part of the code that allows a node to sign things and to validate other wallet's transactions and signatures.

This will be done through either the RSA or DSA algorithm, as these are the most common and well-known signature algorithms and I can be sure that they work without having to design and test my own signature algorithm.

* [ ] Choose between the RSA and DSA algorithm
* [ ] Implement the algorithm key generation using either a pre-made library or a custom built solution
* [ ] Generate key pairs for the chosen algorithm
* [ ] Build a verification function to ensure the key pair was generated properly by signing some random data and checking it.

### Usability Features

* The ability to generate keys as needed if the user doesn't have any to reduce friction.
* Once key pair has been either inputted or generated the user shouldn't have to worry about them during the Node's run time.

### Key Variables

| Variable Name | Use                                                                                                                                                                                          |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| private\_key  | This is a private key that should not be shared and is used to sign data.                                                                                                                    |
| public\_key   | This is a publicly available key derived from the private key that can be used to validate that a specific private key produced a signature. Can also be used as an identifier for a wallet. |

## Choosing a Signature Algorithm

Before this part of the program can be designed and programmed, it is first required to choose a signature algorithm for generating signatures and validating transactions and therefore blocks.

The main two ways to do this are using either the RSA or DSA algorithms, both of which are considered safe and secure algorithms as of 2022, and can both be used for use case of which I will be using them for in this project.

{% tabs %}
{% tab title="RSA" %}
#### Summary:

* Primarily used for secure data transmission
* Developed in 1977 by **Ron Rivest**, **Adi Shamir** and **Leonard Adleman**.
* Uses the factorisation of product of two large primes for its mathematical security.
* Faster Encryption than DSA
* Slower Decryption than DSA

#### A basic diagram of how RSA works. [(GeeksforGeeks, 2020)](../reference-list.md)



<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>
{% endtab %}

{% tab title="DSA" %}
#### Summary

* Primarily used for secure digital signature and verification
* Developed in 1991 by **National Institute of Standards and Technology (NIST)**.
* Uses modular exponentiation and discrete logarithm to ensure mathematical security.
* Slower encryption compared to RSA.
* Faster decryption than RSA.

#### A basic diagram of how DSA works. [(GeeksforGeeks, 2020)](../reference-list.md)

<figure><img src="../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>
{% endtab %}
{% endtabs %}

Due to DSA being primarily used and tested for signature and verification thus having being tested for the use case of which I will be using it for and having faster decryption than RSA - which will be used a lot more than encryption during the project - I will be using the DSA algorithm for this project.

## Design

### Pseudocode

Objective 1 solution:

```
```

Objective 2 solution:

```
```

## Development

Most of the development for this cycle was just setup, to get everything I need for this project up and running and building out the structure of the codebase in order to make the actual programming as smooth as possible.

### Outcome

Objective 1

```
code
```

Objective 2

```
code
```

### Challenges

Challenges faced in either/both objectives

## Testing

### Tests

| Test | Instructions | What I expect | What actually happens | Pass/Fail |
| ---- | ------------ | ------------- | --------------------- | --------- |
| 1    |              |               |                       |           |
| 2    |              |               |                       |           |
| 3    |              |               |                       |           |

### Evidence

(Images of tests running/results)
